---
output:
  pdf_document:
    latex_engine: xelatex

title: Конспекты по курсу "Операционные системы"
author:

mainfont: DejaVuSerif.ttf
sansfont: DejaVuSans.ttf
monofont: DejaVuSansMono.ttf
mathfont: texgyredejavu-math.otf

numbersections: true
indent: true

header-includes:
- \usepackage{indentfirst}
- \usepackage[russian]{babel}
---

\tableofcontents

# Язык x86 ассемблера
В примерах в данном разделе будет использоваться язык x86 ассемблера (64-bit)
и синтаксис AT&T.

## Инструкция `mov`
Одна из самых незамысловатых инструкций --- инструкция `mov`. Она копирует значение из источника в назначение.

```
movq <src>, <dst>       # Использование movq означает копирование 64-bit значений.
movq %RAX, %RBX         # Копирование значения из регистра RAX в RBX.
movq (%RAX), %RBX       # Копирование значения из адреса в памяти в RAX в RBX.
                        # () означают разыменование значения, как адреса в памяти.
movq $42, %RAX            # Перенос 42 в RAX. Знак '$' обязателен, так как в противном
                        # случае число будет интерпретировано, как адрес в памяти.
movq 42, %RAX           # Перенос 8-bit значения из адреса памяти 42 в RAX.
```

## Инструкции `add` и `sub`

Рассмотрим простые арифметические инструкции. Начнем с инструкции `add` --- инструкции сложения.

```
addq <src> <dst>        # addq добавляет 64-bit значение <src> в <dst>.
addq %RAX, %RBX         # добавляет значение RAX в RBX.
addq %RAX, value        # добавляет значение из RAX в память по адресу value.
addq $42, %RAX          # добавляет значение 42 в RAX.
```

Инструкция `sub` действует похожим образом. Она вычитает первый аргумент из второго.
```
sub <src>, <dst>
```

## Инструкции `mul`
Рассмотрим инструкцию беззнакового умножения --- `mul`.
```
mulq <op>   # Умножает значение <op> и RAX и сохраняет младшие 64-bit
            # результата в RAX, а старшие 64-bit результата --- в RDX.
```
```
RAX = (<op> * RAX) mod 2^64
RDX = (<op> * RAX) / 2^64
```

При использовании mulq явно не указывается регистр RAX, однако он используется всегда.
Также, старшие биты результата умножения, которые не влезли в RAX --- сохраняются в RDX.
Можно сделать вывод, что результат mulq записывается как 128-bit число.

## Инструкция `div`
Рассмотрим инструкцию беззнакового деления --- `div`

```
divq <op>    # Вычисляет сразу два значения от <op>: частное,
             # которое попадает в RAX, и остаток от
             # деления, который попадает в RDX.
```
```
RDX = (RDX * 2^64 + RAX) mod <op>
RAX = (RDX * 2^64 + RAX) / <op>
```

## Стек
Стек --- это область памяти, на которую указывает регистр RSP.
Чтобы положить значение на стек, необходимо воспользоваться инструкцией
`push`.
Рассмотрим на примере `pushq` --- восьмибайтном эквиваленте `push`.
```
pushq <src>    # Уменьшает RSP на 8, и сохраняет по полученному адресу src.
```
Важно понимать, что стек растет от HIGH адреса памяти к LOW.

Для того, чтобы "взять" значение со стека необходимо воспользоватся командой
`pop`.
Рассмотрим на примере `popq` --- восьмибайтном эквиваленте `pop`.
```
popq <dst>    # Обратное действие к pushq.
```
Если же требуется не удалить значение со стека, а просто его считать, то это
можно сделать следующим образом.

```
movq (%RSP), %RAX    # Копирует значение с верхушки стека в RAX.
```

Дополнительно можно отметить, что `pushq` и `popq` можно заменить при помощи
`movq`, `addq` и `subq`

## Метки
Метка --- это имя, которое ссылается на некий адрес памяти. Ссылаться можно
не только на адреса каких-то данных, но и на адреса какого-то кода.
```
        .data
value:
        .quad 42

        .text
add42:
        movq %RDI, %RAX
        addq value, %RAX
        retq
```

## Инструкции безусловного перехода
Инструкции безусловного перехода изменяют значение регистра RIP.

```
jmp <label>     # Записываем в RIP адрес, на который указывает метка.
```
```
call <label>    # Записывает в RIP адрес и делает дополнительные.
                # Манипуляции, требуемые для вызова функции.
```
```
retq            # Возвращает из функции.
```

## Функции
Функцию можно вызвать. При завершении функции --- требуется вернуть контроль
в то же место, откуда функция была вызвана, а для этого, нужно сохранить
информацию о том, откуда функция была вызвана --- адрес возврата.

Адрес возврата сохраняется на стеке, поэтому, если при исполнения кода функции
записывались какие-либо значения на стек, то их нужно убрать перед `retq`.

## Флаговый регистор RFLAGS
Флаговый регистр хранит флаги.

Вот некоторые флаги регистра `RFLAGS`:

* `ZF` --- результат операции `0`;
* `CF` --- произошло беззнаковое переполнение;
* `OF` --- произошло знаковое переполнение;

...

## Инструкции условного перехода
```
jcc <label>    # Выполняет переход, если условие cc истинно.
```
* `jz`, `je` --- проверяют, что `ZF = 1`;
* `jne`, `jnz` --- проверяют, что `ZF = 0`;
* `jg` --- если "больше" (знаковый вариант);
* `jge` --- если "больше или равно" (знаковый вариант);

## Инструкции сравнения
Существуют команды, которые изменяют значение флагового регистра, но при этом
не изменяют свои аргументы. Рассмотрим инструкцию сравнения `cmpq`.

```
cmpq <src> <dst>  # вычисляет разность меду <dst> и <src> и выставляет флаги.
```
Работает данная инструкция также, как и subq, но при этом не изменяет dst.


## Пример задания №1
### Условие
Теперь более сложное задание. Вам требуется написать функцию pow, которая
принимает на вход два беззнаковых числа x x x и p p p (в регистрах RDI и RSI
соответственно) и возвращает значение xp x^p xp в регистре RAX. Гарантируется,
что x x x и p p p не могут быть равны 0 одновременно (по отдельности они все
еще могут быть равны 0). Также гарантируется, что ответ помещается в 64 бита.

ВАЖНО: не забудьте, что кроме инструкций условного перехода (jcc) есть и
инструкция безусловного перехода jmp - она может вам пригодиться.

### Решение
```
pow:
    movq $1, %RAX
    cmpq $0, %RSI
    jz ret_f

cycle:
    mulq %RDI
    subq $1, %RSI
    jz ret_f
    jmp cycle

ret_f:
    retq
```


## ABI
ABI (Application Binary Interface) -- набор соглашений следующих:

* Как в функцию передаются параметры;
* Какие функция возвращает значения;
* Какие регистры функция должна сохранить, а какие может испортить;

и.т.д

Данный набор соглашений нужен, например для того, чтобы некие модули, собранные
разными компиляторами могли взаимодействовать и работать вместе корректно.

# Прерывания
Прерывание --- это событие, которое заставляет процессор прервать текущую задачу
и вызвать специальный обработчик.

Важным свойством прерываний является то, что они происходят асинхронно, т.е.
программа никак не ожидает того, что произойдет некое прерывание.

Обработчики прерываний --- это часть ядра операционной системы.

## Вызов обработчика прерываний
## Error Code
Некоторые прерывания соответствуют ошибочным ситуациям. Для некоторых из них
на стек сохраняется Error Code.

Error Code, иногда, содержит полезную для обработки ошибки информацию.

## Завершение обработчика прерываний
Обработчик прерывания обычно завершается инструкцией `iretq`.
Для прерываний, сохраняющих Error Code, его необходимо удалить со стека перед
вызовом `iretq`.

## Тело обработчика прерываний
В общем случае, тело обработчика прерывания зависит от самого обработчика
прерывания, так как разные прерывания требуют разной обработки.

Несмотря на сказанное выше, тела обработчиков прерываний обладают некоторыми общими
свойствами.

Обычно, процессор сохраняет минимум информации о прерванном коде. Он сохраняет
`RIP`, `RFLAGS`, но этого обычно недостаточно, потому что прерванный код мог
заниматься, например, вычислением чего-то в момент прерывания и сохранять
промежуточные результаты в регистры общего назначения.

Таким образом, чтобы не допустить подобного, все обработчики прерывания должны
содержать в себе код для сохранения регистров общего назначения и восстановления
значений перед завершением обработчика прервания.

## Таблица дескрипторов прерываний
Чтобы понять, какой обработчик прерывания вызывать, процессор x86 использует
специальную таблицу, которая называется `IDT` --- таблица дескрипторов прерываний.
Адресс, по которому находится таблица прерываний, находится в специальном
регистре `IDTR`.

Специальные инструкции `LIDT` и `SIDT` позволяют записать или прочитать
регистр `IDT`.

В `IDT` может максимально храниться 256 записей, т.е. каждое ядро может
обрабатывать 256 различных прерываний.

Первые 32 записи `IDT` на каждом ядре зарезервированы под служебные нужды.

## Прерывания от внешних устройств
Остальные записи, кроме служебных, могут быть использованы для обработчиков
прерываний от внешних устройств.

Какая запись какому устройству соответствует может определяться несколькими
способами.

Во-первых, это может определяться настройкой устройства. Т.е, когда драйвер
инициализирует устройство, он может узнать у операционной системы, какое поле в
IDT свободно для использования и использовать его, сохранив номер поля в
устройство. В таком случае, устройство сможет посылать прерывание, указывая, что
адрес обработчика прерывания находится по определенному номеру в таблице.

Во-вторых, это может быть задано конфигурацией некого контроллера прерывания,
который вместо устройства отправляет прерывания процессору.

## Контроллер прерываний
Контроллер прерываний --- это посредник между устройствами и процессором.
Устройства посылают сигналы контроллеру, а контроллер, в свою очередь, отправляет
процессору прерывания. Это может быть нужно например для того, чтобы выстроить
четкую последовательность обработки прерываний от устройств.


Примеры контроллеров прерывания для x86:

* PIC (Programmable Interrupt Controller) (Intel 8259);
* APIC (Advanced PIC) (Local APIC + IO APIC).

## Запрет прерываний
Прерывания требуется запрещать, например, для случаев, когда выполняется какое-то
неатомарное, прерывание которого приведет к неконсистентности данных.

Важно отметить, что запрещать можно только прерывания от внешних устройств.
Прерывания из-за ошибок запрещать нельзя.

Если мы знаем, какое прерывание может превести к проблемам, и устройство, которое
генерирует это прерывание, позволяет --- мы можем попросить устройство не
генерировать прерывания. Если же устройство посылает прерывания через контроллер
прерываний, то мы можем попросить контроллер, не посылать прерывания.

Также, мы можем запретить принимать прерывания со стороны процессора.

x86 регистр `RFLAGS` содержит флаг `IF`. Инструкция `cli` используется для
очищения флага `IF`, тем самым, запрещая прерывания.

Инструкция `sti` устанавливает флаг `IF`, разрешая прерывания.

# Операционные системы
## Загрузка ОС
### Первая инструкция
После подачи питания процессор должен начать исполнять какие-то инструкции.
Процессоры x86 обращаются по адресу `0xFFFFFFF0`.
Как правило, по этому адресу отвечает не память, а материнская плата.
Материнская плата далее направляет процессор на исполнение кода BIOS/UEFI.

### BIOS
BIOS обычно начинает свою работу с POST --- Power-On Self-Test.
После этого, BIOS ищет загрузочный диск и передает коду с этого диска управление.
Для BIOS загрузочный диск --- это диск, с которого можно прочитать без ошибок
первые 512 байт (a.k.a загрузочный сектор).
Последние 2 байта сектора должны содержать числа `0x55` и `0xAA`.

Если BIOS определили загрузочный сектор, то далее он загружает этот сектор
в память по магическому физическому адресу `0x7c00`. Далее BIOS отдает управление
коду по адресу `0x7c00`.


